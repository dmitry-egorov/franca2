//var[s u32  0]
//var[i u32 10]
//while[i {}[
//  -=[i 1]
//  +=[s 3]
//]]

//ret[*[+[1 2] +[3 4]]]
ret[-[fib_at[40] fib_at[30]]]

//ret[+[foo[1] 1]]

def[foo disp["foo"#[a u32]] u32 {}[while[1 ret[a]] ret[a]]]

def[fib_at disp["fib at "$[n u32]] u32 {}[
    if[==[n 0] ret[0]]
    if[==[n 1] ret[1]]

    var[i  u32 2]
    var[v0 u32 0]
    var[v1 u32 1]
    while[<=[i n] {}[
        var[t u32 v1]
         +=[v1 v0]
          =[v0 t ]
         +=[i  1 ]]]

    ret[v1]]]

////////////////////////////////////////
def[()  disp["("#[expr u32]")"] u32 expr]
def[=   disp[&[a u32]" = "#[b u32]] void {}[b op_local_set &[a]]]

def[if disp["if "#[a u32]" "#[b void]] void {}[
    a
    op_if vt_void
        b
    op_end]]

def[while disp["while "#[a u32]" "#[b void]] void {}[
    op_block vt_void
        op_loop vt_void
            a
            op_i32_eqz
            op_br_if[1]
                b
            op_br[0]
        op_end
    op_end]]

def[+ disp[#[a u32]" + "#[b u32]] u32 {}[a b op_i32_add]]
def[- disp[#[a u32]" - "#[b u32]] u32 {}[a b op_i32_sub]]
def[* disp[#[a u32]" * "#[b u32]] u32 {}[a b op_i32_mul]]
def[/ disp[#[a u32]" / "#[b u32]] u32 {}[a b op_i32_div_u]]
def[% disp[#[a u32]" % "#[b u32]] u32 {}[a b op_i32_rem_u]]

def[== disp[#[a u32]" == "#[b u32]] u32 {}[a b op_i32_eq]]
def[!= disp[#[a u32]" == "#[b u32]] u32 {}[a b op_i32_ne]]
def[<  disp[#[a u32]" < " #[b u32]] u32 {}[a b op_i32_lt_u]]
def[>  disp[#[a u32]" > " #[b u32]] u32 {}[a b op_i32_gt_u]]
def[<= disp[#[a u32]" <= "#[b u32]] u32 {}[a b op_i32_le_u]]
def[>= disp[#[a u32]" >= "#[b u32]] u32 {}[a b op_i32_ge_u]]

def[- disp["-"#[a u32]] u32 {}[0 a op_i32_sub]]

def[+= disp[&[a u32]" += "#[b u32]] void =[a +[a b]]]
def[-= disp[&[a u32]" -= "#[b u32]] void =[a -[a b]]]

def[floor disp["floor "#[a f32]] f32 {}[a op_f32_nearest]]

// $    -- add var on expansion
// &    -- local reference
// #    -- pass nodes to emit later
// emit -- scope that allows emitting

// alt:
// const[wasm.return    u8 0x0f]
// const[wasm.local.get u8 0x20]
// const[wasm.local.set u8 0x21]
// ...

// def[loop disp["loop "#[b u32]] void wasm[wasm.loop scope[b wasm.br 1] wasm.end]]

// separate display and signature, because some parameters can be in different order or even missing from view (e.g. type parameters)
// def[+ ..[#[a u32] #[b u32]] u32 ..[a" + "b] {}[a b op_i32_add]]

//Need 'identifier' parameter kind
// def[var disp["var "id[name]": "id[type]" = " #[value u32]] void =[local[name type] value]]

