// print_str["Hello, world!"]
//
// var[dst u32 1024]
//
// var[x u32 123]
// push_str["x = " dst]
// push_str[x      dst]
//
// print_str[1024 -[dst 1024]]
//
// ret[-[fib_at[40] fib_at[30]]]

ret[-[foo[53] 11]]

def[foo[.[x[$ u32]] u32 .[if[==[x 53] ret[+[x 1]]] ret[+[x 2]]]]]

// print["x = " x]
// def[
//     print[.[##] . print_str[istr[##]]]
//     istr [.[##] str .[
//         var[buf u32 1024]
//         var[dst u32 buf ]
//         ## [push_str[arg dst]] // with overloading
//         ret[make_str[buf -[dst buf]]]
//     ]]
// ]

// --- polymorphic functions
// def[
//     test[. . foo[32]]
//     foo [.[x[# any]] . bar[x]]
//     bar [.[x[# u32]] . print_str["u32"]]
//     bar [.[x[# f32]] . print_str["f32"]]
// ]

////////////////////////////////////////
def[fib_at[.[n[$ u32]] u32 .[
    if[==[n 0] ret[0]]
    if[==[n 1] ret[1]]

    var[i  u32 2]
    var[v0 u32 0]
    var[v1 u32 1]
    while[<=[i n] .[
        var[t u32 v1]
         +=[v1 v0]
          =[v0 t ]
         +=[i  1 ]]]

    ret[v1]]]]

////////////////////////////////////////
def[
    print_str[.[ptr[# u32] len[# u32]] . .[print_str[make_str[ptr len]]]]

    push_str[.[n[$ u32] dst[& u32]] . .[
        if[==[n 0] .[push_chr[chr[0] dst] ret]]

        var[d u32 1000000000]
        while[>[d n] /=[d 10]]

        while[>[d 0] .[
            push_chr[()[+[chr[0] %[()[/[n d]] 10]]] dst]
            /=[d 10]]]]]

    push_str[.[s [$ str] dst[& u32]] . .[copy_str[s  dst] +=[dst sub[1 s]]]]
    push_chr[.[ch[$ u32] dst[& u32]] . .[store_u8[ch dst] +=[dst 1]]]

    make_str[.[ptr[# u32] len[# u32]] str .[ptr len]]
    copy_str[.[s  [$ str] dst[$ u32]] .   .[mem_copy[sub[0 s] sub[1 s] dst]]]

    mem_copy[.[src[# u32] count[# u32] dst[# u32]] . .[dst src count op_memory_copy[0 0]]]
    store_u8[.[ch [# u32]              dst[# u32]] . .[dst ch op_i32_store8[0 0]]]

    if[.[a[# u32] b[# .]] . .[
        a
        .[op_if vt_void
            b
        op_end]]]

    while[.[a[# u32] b[# .]] . .[
        {}[
            .[op_loop vt_void
                a
                op_i32_eqz
                op_br_if[1]
                    b
                op_br[0]
            op_end]
        ]]]

    floor[.[a[# f32]] f32 .[a op_f32_nearest]]

    ()[.[a[# u32]] u32 a]
    {}[.[a[# void]] vt_void .[
        .[op_block vt_void
            a
        op_end]]]

    + [.[a[# u32] b[# u32]] u32 .[a b op_i32_add  ]]
    - [.[a[# u32] b[# u32]] u32 .[a b op_i32_sub  ]]
    * [.[a[# u32] b[# u32]] u32 .[a b op_i32_mul  ]]
    / [.[a[# u32] b[# u32]] u32 .[a b op_i32_div_u]]
    % [.[a[# u32] b[# u32]] u32 .[a b op_i32_rem_u]]

    ==[.[a[# u32] b[# u32]] u32 .[a b op_i32_eq  ]]
    !=[.[a[# u32] b[# u32]] u32 .[a b op_i32_ne  ]]
    < [.[a[# u32] b[# u32]] u32 .[a b op_i32_lt_u]]
    > [.[a[# u32] b[# u32]] u32 .[a b op_i32_gt_u]]
    <=[.[a[# u32] b[# u32]] u32 .[a b op_i32_le_u]]
    >=[.[a[# u32] b[# u32]] u32 .[a b op_i32_ge_u]]

    - [.[a[# u32]] u32 .[0 a op_i32_sub]]

    +=[.[a[& u32] b[# u32]] . =[a +[a b]]]
    -=[.[a[& u32] b[# u32]] . =[a -[a b]]]
    *=[.[a[& u32] b[# u32]] . =[a *[a b]]]
    /=[.[a[& u32] b[# u32]] . =[a /[a b]]]
    %=[.[a[& u32] b[# u32]] . =[a %[a b]]]

    = [.[a[& u32] b[# u32]] . .[b op_local_set &[a]]]

    as_u32[.[a[# f32]] u32 .[a op_i32_trunc_f32_u]]
    as_i32[.[a[# f32]] u32 .[a op_i32_trunc_f32_s]]
]

// $    -- add var on expansion
// &    -- local reference
// #    -- pass nodes to emit later
// emit -- scope that allows emitting

// alt:
// const[wasm.return    u8 0x0f]
// const[wasm.local.get u8 0x20]
// const[wasm.local.set u8 0x21]
// ...

// Need 'identifier' parameter kind
// def[var[.[name[# id] type[# id] init_value[# u32] disp["var "name": "type" = "value] . .[=[local[name type] value]]]

// No overloading
// +_u32[.[a[# u32] b[# u32]] u32 .[a b op_i32_add]]

// Generics, no overloading
// +[.[t[# type] a[# t] b[# t]] t .[a b op_map[+ t]]]

// need comptime for this
// = [.[t[# type] a[& t] b[# t]] . .[
//     b
//     #for[..[0 size_32_of[type]] .[
//         op_local_set +[&[a] -[-[size 1] i]]]] // we set in reverse order
// ]

// Generics
//  as[.[a[# u32] t[# type]] t .[a]]

// comptime?
// const[x u32 +[1 2]]
// const[y u32 +[x 1]]

