//print_str["Hello, world!"]

var[dst u32 1024]

var[x u32 123]
push_str["x = "dst]
push_str[x dst]

print_str[1024 -[dst 1024]]

ret[-[fib_at[40] fib_at[30]]]

////////////////////////////////////////
// print[.["x = " x]]
// print["x = " x]

def[print[a[# .] . print_str[istr[a]]]]

def[istr[a[# .] str .[
    var [buf u32 1024]
    var [dst u32 buf ]
    each[a push_str[it dst]]
    ret [make_str[buf -[dst buf]]]
]]]

// def[print[## . print_str[istr[##]]]]
//
// def[istr[## str .[
//     var[buf u32 1024]
//     var[dst u32 buf ]
//     ## [push_str[it dst]]
//     ret[make_str[buf -[dst buf]]]
// ]]]

////////////////////////////////////////
def[fib_at[n[$ u32] u32 .[
    if[==[n 0] ret[0]]
    if[==[n 1] ret[1]]

    var[i  u32 2]
    var[v0 u32 0]
    var[v1 u32 1]
    while[<=[i n] .[
        var[t u32 v1]
         +=[v1 v0]
          =[v0 t ]
         +=[i  1 ]]]

    ret[v1]]]]

////////////////////////////////////////
def[
    print_str[.[ptr[# u32] len[# u32]] . .[print_str[make_str[ptr len]]]]

    push_str[.[n[$ u32] dst[& u32]] . .[
        if[==[n 0] .[push_chr[chr[0] dst] ret]]

        var[d u32 1000000000]
        while[>[d n] /=[d 10]]

        while[>[d 0] .[
            push_chr[()[+[chr[0] %[()[/[n d]] 10]]] dst]
            /=[d 10]]]]]

    push_str[.[s [$ str] dst[& u32]] . .[copy_str[s  dst] +=[dst sub_of[1 s]]]]
    push_chr[.[ch[$ u32] dst[& u32]] . .[store_u8[ch dst] +=[dst 1]]]

    make_str[.[ptr[# u32] len[# u32]] str .[ptr len]]
    copy_str[.[s  [$ str] dst[$ u32]] .   .[mem_copy[sub_of[0 s] sub_of[1 s] dst]]]

    mem_copy[.[src[# u32] count[# u32] dst[# u32]] . .[dst src count op_memory_copy[0 0]]]
    store_u8[.[ch [# u32]              dst[# u32]] . .[dst ch op_i32_store8[0 0]]]

    if[.[a[# u32] b[# .]] . .[
        a
        op_if vt_void
            b
        op_end]]

    while[.[a[# u32] b[# .]] . .[
        op_block vt_void
            op_loop vt_void
                a
                op_i32_eqz
                op_br_if[1]
                    b
                op_br[0]
            op_end
        op_end]]

    floor[.[a[# f32]] f32 .[a op_f32_nearest]]

    ()[a[# u32] u32 a]

    + [.[a[# u32] b[# u32]] u32 .[a b op_i32_add  ]]
    - [.[a[# u32] b[# u32]] u32 .[a b op_i32_sub  ]]
    * [.[a[# u32] b[# u32]] u32 .[a b op_i32_mul  ]]
    / [.[a[# u32] b[# u32]] u32 .[a b op_i32_div_u]]
    % [.[a[# u32] b[# u32]] u32 .[a b op_i32_rem_u]]

    ==[.[a[# u32] b[# u32]] u32 .[a b op_i32_eq  ]]
    !=[.[a[# u32] b[# u32]] u32 .[a b op_i32_ne  ]]
    < [.[a[# u32] b[# u32]] u32 .[a b op_i32_lt_u]]
    > [.[a[# u32] b[# u32]] u32 .[a b op_i32_gt_u]]
    <=[.[a[# u32] b[# u32]] u32 .[a b op_i32_le_u]]
    >=[.[a[# u32] b[# u32]] u32 .[a b op_i32_ge_u]]

    - [a[# u32] u32 .[0 a op_i32_sub]]

    +=[.[a[& u32] b[# u32]] . =[a +[a b]]]
    -=[.[a[& u32] b[# u32]] . =[a -[a b]]]
    *=[.[a[& u32] b[# u32]] . =[a *[a b]]]
    /=[.[a[& u32] b[# u32]] . =[a /[a b]]]
    %=[.[a[& u32] b[# u32]] . =[a %[a b]]]

    = [.[a[& u32] b[# u32]] . .[b op_local_set &[a]]]]

// $    -- add var on expansion
// &    -- local reference
// #    -- pass nodes to emit later
// emit -- scope that allows emitting

// alt:
// const[wasm.return    u8 0x0f]
// const[wasm.local.get u8 0x20]
// const[wasm.local.set u8 0x21]
// ...

// def[loop disp["loop "#[b u32]] . wasm[wasm.loop scope[b wasm.br 1] wasm.end]]

// separate display and signature, because some parameters can be in different order or even missing from view (e.g. type parameters)
// def[+ ..[#[a u32] #[b u32]] u32 .[a" + "b] .[a b op_i32_add]]

//Need 'identifier' parameter kind
// def[var disp["var "id[name]": "id[type]" = " #[value u32]] . .[=[local[name type] value]]]

